---
title: "Análise de Contagens com Modelo Poisson Generalizado"
author: >
  Walmes M. Zeviani,
  Eduardo E. Ribeiro Jr &
  Cesar A. Taconeli
vignette: >
  %\VignetteIndexEntry{"Análise de Contagens com Modelo Poisson Generalizado"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
source("_setup.R")
```

```{r, message=FALSE, error=FALSE, warning=FALSE}
# Definições da sessão.
# devtools::load_all("../")
library(lattice)
library(latticeExtra)
library(rpanel)
library(bbmle)
library(corrplot)
library(plyr)
library(car)
library(doBy)
library(multcomp)
```

## Função Densidade ##

Se uma variável aleatória $Y$ tem distribuição de probabilidades Poisson
generalizada, então sua função de probabilidade é

$$
f(y) =
\begin{cases}
  \theta (\theta + \gamma y)^{y - 1}
  \exp\{-(\theta + \gamma y)\}, &
  y = 0, 1, 2, \ldots \\
  0, &
  y > m \text{ quando } \gamma < 0
\end{cases}
$$

  - $m$ é maior inteiro positivo para o qual $\theta + m\gamma >
    0$ quando $\gamma$ é negativo. Usa-se $m \geq 4$ para se ter pelo
    menos 4 pontos no suporte com probabilidade não nula (verificar).
  - $\theta > 0$;
  - $\max\{-1, -\theta/m\} < \gamma < 1$;
  - Resolvendo a iniqualdade, tem-se que $m = \left\lfloor
    \frac{-\theta}{\gamma} \right\rfloor$ quando $\gamma < 0$;
  - *Note que o espaço paramétrico de $\gamma$ é dependente do
    parâmetro $\theta$*.

```{r}
# Função densidade na parametrização original.
dpg0 <- function(y, theta, gamma, m = 4) {
    if (gamma < 0) {
        m <- max(c(m, floor(-theta/gamma)))
        if (gamma < max(c(-1, -theta/m))) {
            m <- 0
        } else {
            m <- as.integer(y <= m)
        }
    } else {
        m <- 1
    }
    z <- theta + gamma * y
    k <- lfactorial(y)
    # fy <- m * theta * z^(y - 1) * exp(-z)/exp(k)
    fy <- m * exp(log(theta) + (y - 1) * log(z) - z - k)
    return(fy)
}

# Caso Poisson (gamma == 0).
y <- 0:30
theta <- 10
gamma <- 0

fy <- dpg0(y = y, theta = theta, gamma = gamma)
plot(fy ~ y, type = "h")
lines(y + 0.3, dpois(y, lambda = theta), type = "h", col = 2,
      xlab = "y", ylab = "f(y)")
```

## Recursos interativos  com o `rpanel` ##

```{r, eval=FALSE}
react <- function(panel){
    with(panel,
    {
        m <- THETA/(1 - GAMMA)
        s <- sqrt(THETA/(1 - GAMMA)^3)
        from <- floor(max(c(0, m - 5 * s)))
        to <- ceiling(max(c(YMAX, m + 5 * s)))
        y <- from:to
        py <- dpg0(y = y, theta = THETA, gamma = GAMMA)
        if (POIS) {
            pz <- dpois(y, lambda = m)
        } else {
            pz <- 0
        }
        # Colocar 0 para valores não finitos (-Inf, Inf e NaN) para
        # fazer gráfico.
        py[!is.finite(py)] <- 0
        plot(py ~ y, type = "h",
             ylim = c(0, max(c(py, pz))),
             xlab = expression(y),
             ylab = expression(f(y)))
        mtext(side = 3,
              text = substitute(sum(f(y)) == s,
                                list(s = round(sum(py), 5))))
        if (EX) {
            abline(v = m, col = 2)
        }
        if (POIS) {
            lines(y + 0.3, pz, type = "h", col = 3)
        }
    })
    panel
}

panel <- rp.control(title = "Poisson Generalizada",
                    size = c(300, 100), YMAX = 150, m = 4)
rp.slider(panel = panel, action = react,
          variable = THETA, title = "theta",
          from = 0.1, to = 100,
          initval = 5, resolution = 0.1,
          showvalue = TRUE)
rp.slider(panel = panel, action = react,
          variable = GAMMA, title = "gamma",
          from = -1, to = 0.99,
          initval = 0, resolution = 0.01,
          showvalue = TRUE)
rp.checkbox(panel = panel,
            variable = EX, action = react, title = "E(Y)",
            labels = "Mostrar o valor esperado?")
rp.checkbox(panel = panel,
            variable = POIS, action = react, title = "Poisson",
            labels = "Adicionar a distribução Poisson?")
rp.do(panel = panel, action = react)
```

## Modelo de Regressão com a Distribuição Poisson Generalizada ##

```{r, eval=FALSE}
# Função densidade na parametrização de modelo de regressão.
dpg1 <- function(y, lambda, alpha) {
    k <- lfactorial(y)
    w <- 1 + alpha * y
    z <- 1 + alpha * lambda
    m <- alpha > pmax(-1/y, -1/lambda)
    # fy <- (lambda/z)^(y) * w^(y - 1) * exp(-lambda * (w/z))/exp(k)
    fy <- y * (log(lambda) - log(z)) +
        (y - 1) * log(w) - lambda * (w/z) - k
    fy[!m] <- 0
    return(m * exp(fy))
}

react <- function(panel){
    with(panel,
    {
        m <- LAMBDA
        s <- sqrt(LAMBDA) * (1 + ALPHA * LAMBDA)
        from <- floor(max(c(0, m - 5 * s)))
        to <- ceiling(max(c(YMAX, m + 5 * s)))
        y <- from:to
        py <- dpg1(y = y, lambda = LAMBDA, alpha = ALPHA)
        if (POIS) {
            pz <- dpois(y, lambda = m)
        } else {
            pz <- 0
        }
        py[!is.finite(py)] <- 0
        plot(py ~ y, type = "h",
             ylim = c(0, max(c(py, pz))),
                 xlab = expression(y),
             ylab = expression(f(y)))
        mtext(side = 3,
              text = substitute(sum(f(y)) == s,
                                list(s = round(sum(py), 5))))
        if (EX) {
            abline(v = m, col = 2)
        }
        if (POIS) {
            lines(y + 0.3, pz, type = "h", col = 3)
        }
    })
    panel
}

panel <- rp.control(title = "Poisson Generalizada",
                    size = c(300, 100), YMAX = 150)
rp.slider(panel = panel, action = react,
          variable = LAMBDA, title = "lambda",
          from = 0.1, to = 100,
          initval = 5, resolution = 0.1,
          showvalue = TRUE)
rp.slider(panel = panel, action = react,
          variable = ALPHA, title = "alpha",
          from = -0.1, to = 0.4,
          initval = 0, resolution = 0.01,
          showvalue = TRUE)
rp.checkbox(panel = panel,
            variable = EX, action = react, title = "E(Y)",
            labels = "Mostrar o valor esperado?")
rp.checkbox(panel = panel,
            variable = POIS, action = react, title = "Poisson",
            labels = "Adicionar a distribução Poisson?")
rp.do(panel = panel, action = react)
```

## O Espaço Paramétrico ##

```{r}
#-----------------------------------------------------------------------
# Gráfico do espaço paramétrico de theta x gamma.

# debug(dpg1)
# dpg1(y = 0:10, lambda = 1, alpha = 0)
# dpg1(y = 0:10, lambda = 1, alpha = -0.1)
# undebug(dpg1)

fun <- Vectorize(vectorize.args = c("theta", "gamma"),
                 FUN = function(theta, gamma) {
                     sum(dpg0(y = y, theta = theta, gamma = gamma))
                 })

grid <- list(theta = seq(1, 50, by = 1),
             gamma = seq(-0.5, 1, by = 0.05))
str(grid)

y <- 0:500
my <- max(y)

grid$sum <- with(grid, outer(theta, gamma, fun))
grid <- with(grid,
             cbind(expand.grid(theta = theta, gamma = gamma),
                   data.frame(sum = c(sum))))

levelplot(sum ~ theta + gamma,
          data = subset(grid, round(sum, 3) == 1),
          col.regions = gray.colors) +
    layer(panel.abline(a = 0, b = -1/my)) +
    layer(panel.abline(h = 0, lty = 2))

#-----------------------------------------------------------------------

fun <- Vectorize(vectorize.args = c("lambda", "alpha"),
                 FUN = function(lambda, alpha) {
                     sum(dpg1(y = y, lambda = lambda, alpha = alpha))
                 })

grid <- list(lambda = seq(0.2, 50, by = 0.2),
             alpha = seq(-0.98, 0.98, by = 0.02))
grid$sum <- with(grid, outer(lambda, alpha, fun))

grid <- with(grid,
             cbind(expand.grid(lambda = lambda, alpha = alpha),
                   data.frame(sum = c(sum))))

levelplot(sum ~ lambda + alpha,
          data = subset(grid, round(sum, 3) == 1),
          col.regions = gray.colors) +
    layer(panel.abline(h = 0, lty = 2)) +
    layer(panel.curve(-1/x))

# Já que lambda * alpha > -1, então alpha = -1/lambda dá a fronteira.
```

## Verossimilhança e Estimação ##

```{r}
# Função de log-Verossimilhança da Poisson Generalizada na
# parametrização de modelo de regressão.
llpg <- function(theta, y, X, offset = NULL) {
    # theta: vetor de parâmetros;
    #   theta[1]: parâmetro de dispersão (alpha);
    #   theta[-1]: parâmetro de locação (lambda);
    # y: variável resposta (contagem);
    # X: matriz do modelo linear;
    # offset: tamanho do domínio onde y foi medido;
    #----------------------------------------
    if (is.null(offset)) {
        offset <- 1L
    }
    lambda <- offset * exp(X %*% theta[-1])
    alpha <- theta[1]
    w <- 1 + alpha * y
    z <- 1 + alpha * lambda
    fy <- y * (log(lambda) - log(z)) +
        (y - 1) * log(w) -
        lambda * (w/z) -
        lfactorial(y)
    # Negativo da log-likelihood.
    -sum(fy)
}

#-----------------------------------------------------------------------
# Gerando uma amostra aleatória da Poisson.

# Offset = 2, lambda = 3.
y <- rpois(100, lambda = 2 * 3)

L <- list(y = y,
          offset = rep(2, length(y)),
          X = cbind(rep(1, length(y))))

start <- c(alpha = 0, lambda = 1)
parnames(llpg) <- names(start)

# Como \alpha foi fixado em 1, essa ll corresponde à Poisson.
n0 <- mle2(minuslogl = llpg,
           start = start, data = L,
           fixed = list(alpha = 0), vecpar = TRUE)

# Para conferir.
c(coef(n0)["lambda"],
  coef(glm(y ~ offset(log(L$offset)), family = poisson)))

# Estimando o \alpha.
n1 <- mle2(llpg, start = start, data = L, vecpar = TRUE)
coef(n1)

# Perfil de verossimilhança dos parâmetros.
plot(profile(n1))

# Covariância.
V <- cov2cor(vcov(n1))
corrplot.mixed(V, upper = "ellipse", col = "gray50")
dev.off()
```

## Número de Vagens Produzidas em Soja ##

Experimento fatorial (3 x 5), em delineamento de blocos casualizados,
que estudou a influência de níveis de potássio na adubação em combinação
com irrigação na produção de soja. As variáveis de contagem registradas
nesse experimento foram o número de vagens viáveis (e não viáveis) e o
número total de sementes por parcela.

```{r}
library(lattice)

data(soja, package = "MRDCr")
str(soja)

# A observação 74 é um outlier.
soja <- soja[-74, ]

xyplot(nvag ~ K | umid, data = soja, layout = c(NA, 1),
       type = c("p", "smooth"),
       strip = strip.custom(strip.names = TRUE, var.name = "Umidade"))

soja <- transform(soja, K = factor(K))

#-----------------------------------------------------------------------
# Modelo Poisson.

m0 <- glm(nvag ~ bloc + umid * K, data = soja, family = poisson)

# Diagnóstico.
par(mfrow = c(2, 2))
plot(m0); layout(1)

# Medidas de decisão.
anova(m0, test = "Chisq")
summary(m0)

#-----------------------------------------------------------------------
# Modelo Poisson Generalizado.

L <- with(soja, list(y = nvag, offset = 1, X = model.matrix(m0)))

# Usa as estimativas do Poisson como valore iniciais.
start <- c(alpha = 0, coef(m0))
parnames(llpg) <- names(start)

# Com alpha fixo em 0 corresponde à Poisson.
m2 <- mle2(llpg, start = start, data = L,
           fixed = list(alpha = 0), vecpar = TRUE)

# Mesma medida de ajuste e estimativas.
c(logLik(m2), logLik(m0))
cbind(coef(m2)[-1], coef(m0))

# Poisson Generalizada.
m3 <- mle2(llpg, start = start, data = L, vecpar = TRUE)

# Teste para nulinidade do parâmetro de dispersão (H_0: alpha == 0).
anova(m3, m2)

cbind("PoissonGLM" = c(NA, coef(m0)),
      "PoissonML" = coef(m2),
      "PGeneraliz" = coef(m3))

# Perfil para o parâmetro de dispersão.
plot(profile(m3, which = "alpha"))
abline(v = 0, lty = 2)

V <- cov2cor(vcov(m3))
corrplot.mixed(V, upper = "ellipse", col = "gray50")
dev.off()

# Tamanho das covariâncias com \alpha.
each(sum, mean, max)(abs(V[1, -1]))

# Teste de Wald para a interação.
a <- c(0, attr(model.matrix(m0), "assign"))
ai <- a == max(a)
L <- t(replicate(sum(ai), rbind(coef(m3) * 0), simplify = "matrix"))
L[, ai] <- diag(sum(ai))

# Cáclculo da estatística Chi-quadrado.
# t(L %*% coef(m3)) %*%
#     solve(L %*% vcov(m3) %*% t(L)) %*%
#     (L %*% coef(m3))
crossprod(L %*% coef(m3),
          solve(L %*% vcov(m3) %*% t(L),
                L %*% coef(m3)))

# Teste de Wald para interação (poderia ser LRT, claro).
# É necessário um objeto glm.
linearHypothesis(model = m0,
                 hypothesis.matrix = L,
                 vcov. = vcov(m3),
                 coef. = coef(m3))

#-----------------------------------------------------------------------
# Predição com bandas de confiança.

X <- LSmatrix(m0, effect = c("umid", "K"))

pred <- attr(X, "grid")
pred <- transform(pred,
                  K = as.integer(K),
                  umid = factor(umid))
pred <- list(pois = pred, pgen = pred)

# Quantil normal.
qn <- qnorm(0.975) * c(lwr = -1, fit = 0, upr = 1)

# Preditos pela Poisson.
# aux <- predict(m0, newdata = pred$pois, se.fit = TRUE)
# aux <- exp(aux$fit + outer(aux$se.fit, qn, FUN = "*"))
# pred$pois <- cbind(pred$pois, aux)
aux <- confint(glht(m0, linfct = X),
               calpha = univariate_calpha())$confint
colnames(aux)[1] <- "fit"
pred$pois <- cbind(pred$pois, exp(aux))
str(pred$pois)

# Matrix de covariância completa e sem o alpha (marginal).
V <- vcov(m3)
V <- V[-1, -1]

U <- chol(V)
aux <- sqrt(apply(X %*% t(U), MARGIN = 1,
                  FUN = function(x) { sum(x^2) }))
pred$pgen$eta <- c(X %*% coef(m3)[-1])
pred$pgen <- cbind(pred$pgen,
                   apply(outer(aux, qn, FUN = "*"), MARGIN = 2,
                         FUN = function(x) {
                             exp(pred$pgen$eta + x)
                         }))

pred <- ldply(pred, .id = "modelo")
pred <- arrange(pred, umid, K, modelo)

key <- list(type = "o", divide = 1,
            lines = list(pch = 1:nlevels(pred$modelo),
                         lty = 1, col = 1),
            text = list(c("Poisson", "Poisson Generelizada")))

xyplot(fit ~ K | umid, data = pred,
       layout = c(NA, 1), as.table = TRUE,
       xlim = extendrange(range(pred$K), f = 0.1),
       key = key, pch = pred$modelo,
       xlab = expression("Dose de potássion"~(mg~dm^{-3})),
       ylab = "Número de vagens por parcela",
       ly = pred$lwr, uy = pred$upr, cty = "bars", length = 0,
       prepanel = prepanel.cbH,
       desloc = 8 * scale(as.integer(pred$modelo), scale = FALSE),
       panel = panel.cbH)
```

## Número de Grãos Produzidas em Soja ##

Análise do número de grãos por pacela do experimento com soja.

```{r}
#-----------------------------------------------------------------------

xyplot(ngra ~ K | umid, data = soja, layout = c(NA, 1),
       type = c("p", "smooth"),
       strip = strip.custom(strip.names = TRUE, var.name = "Umidade"))

#-----------------------------------------------------------------------
# Modelo Poisson.

m0 <- glm(ngra ~ bloc + umid * K, data = soja, family = poisson)

# Diagnóstico.
par(mfrow = c(2, 2))
plot(m0); layout(1)

# Medidas de decisão.
anova(m0, test = "Chisq")
summary(m0)

#-----------------------------------------------------------------------
# Modelo Poisson Generalizado.

L <- with(soja, list(y = ngra, offset = 1, X = model.matrix(m0)))

# Usa as estimativas do Poisson como valore iniciais.
start <- c(alpha = 0, coef(m0))
parnames(llpg) <- names(start)

# Com alpha fixo em 0 corresponde à Poisson.
m2 <- mle2(llpg, start = start, data = L,
           fixed = list(alpha = 0), vecpar = TRUE)

# Mesma medida de ajuste e estimativas.
c(logLik(m2), logLik(m0))

# Poisson Generalizada.
m3 <- mle2(llpg, start = start, data = L, vecpar = TRUE)

# Teste para nulinidade do parâmetro de dispersão (H_0: alpha == 0).
anova(m3, m2)

cbind("PoissonGLM" = c(NA, coef(m0)),
      "PoissonML" = coef(m2),
      "PGeneraliz" = coef(m3))

# Perfil para o parâmetro de dispersão.
plot(profile(m3, which = "alpha"))
abline(v = 0, lty = 2)

V <- cov2cor(vcov(m3))
corrplot.mixed(V, upper = "ellipse", col = "gray50")
dev.off()

# Tamanho das covariâncias com \alpha.
each(sum, mean, max)(abs(V[1, -1]))

# Teste de Wald para a interação.
a <- c(0, attr(model.matrix(m0), "assign"))
ai <- a == max(a)
L <- t(replicate(sum(ai), rbind(coef(m3) * 0), simplify = "matrix"))
L[, ai] <- diag(sum(ai))

# Cáclculo da estatística Chi-quadrado.
crossprod(L %*% coef(m3),
          solve(L %*% vcov(m3) %*% t(L),
                L %*% coef(m3)))

linearHypothesis(model = m0,
                 hypothesis.matrix = L,
                 vcov. = vcov(m3),
                 coef. = coef(m3))

#-----------------------------------------------------------------------
# Predição com bandas de confiança.

X <- LSmatrix(m0, effect = c("umid", "K"))

pred <- attr(X, "grid")
pred <- transform(pred,
                  K = as.integer(K),
                  umid = factor(umid))
pred <- list(pois = pred, pgen = pred)

# Quantil normal.
qn <- qnorm(0.975) * c(lwr = -1, fit = 0, upr = 1)

# Preditos pela Poisson.
aux <- confint(glht(m0, linfct = X),
               calpha = univariate_calpha())$confint
colnames(aux)[1] <- "fit"
pred$pois <- cbind(pred$pois, exp(aux))
str(pred$pois)

# Matrix de covariância completa e sem o alpha (marginal).
V <- vcov(m3)
V <- V[-1, -1]

U <- chol(V)
aux <- sqrt(apply(X %*% t(U), MARGIN = 1,
                  FUN = function(x) { sum(x^2) }))
pred$pgen$eta <- c(X %*% coef(m3)[-1])
pred$pgen <- cbind(pred$pgen,
                   apply(outer(aux, qn, FUN = "*"), MARGIN = 2,
                         FUN = function(x) {
                             exp(pred$pgen$eta + x)
                         }))

pred <- ldply(pred, .id = "modelo")
pred <- arrange(pred, umid, K, modelo)
str(pred)

key <- list(type = "o", divide = 1,
            lines = list(pch = 1:nlevels(pred$modelo),
                         lty = 1, col = 1),
            text = list(c("Poisson", "Poisson Generelizada")))

xyplot(fit ~ K | umid, data = pred,
       layout = c(NA, 1), as.table = TRUE,
       xlim = extendrange(range(pred$K), f = 0.1),
       key = key, pch = pred$modelo,
       xlab = expression("Dose de potássion"~(mg~dm^{-3})),
       ylab = "Número de grãos por parcela",
       ly = pred$lwr, uy = pred$upr, cty = "bars", length = 0,
       prepanel = prepanel.cbH,
       desloc = 8 * scale(as.integer(pred$modelo), scale = FALSE),
       panel = panel.cbH)
```

## Número de Grãos por Vagem ##

```{r}
#-----------------------------------------------------------------------
# Número de grãos por vagem.

xyplot(ngra/nvag ~ K | umid, data = soja, layout = c(NA, 1),
       type = c("p", "smooth"),
       strip = strip.custom(strip.names = TRUE, var.name = "Umidade"))

#-----------------------------------------------------------------------
# Modelo Poisson.

m0 <- glm(ngra ~ offset(log(nvag)) + bloc + umid * K,
          data = soja, family = poisson)

# Diagnóstico.
par(mfrow = c(2, 2))
plot(m0); layout(1)

# Medidas de decisão.
anova(m0, test = "Chisq")
summary(m0)

#-----------------------------------------------------------------------
# Modelo Poisson Generalizado.

L <- with(soja, list(y = ngra, offset = nvag, X = model.matrix(m0)))

# Já que na verossimilhaça (1 + alpha * y) > -1, então o menor valor
# possível para gamma para ter uma log-verossimilhança avaliável é
-1/max(soja$ngra)

# Mesmo com esse lower bound, o valor chute para alpha foi definido por
# tentativa erro. O valor -0.003 dá Error e o valor -0.002 na hora de
# perfilhar encontra um mínimo melhor. Então, por tentativa erro
# chegou-se no -0.0026.
start <- c(alpha = -0.0026, coef(m0))
parnames(llpg) <- names(start)

# Com alpha fixo em 0 corresponde à Poisson.
m2 <- mle2(llpg, start = start, data = L,
           fixed = list(alpha = 0), vecpar = TRUE)

# Mesma medida de ajuste e estimativas.
c(logLik(m2), logLik(m0))

# Poisson Generalizada.
m3 <- mle2(llpg, start = start, data = L, vecpar = TRUE)

# Teste para nulinidade do parâmetro de dispersão (H_0: alpha == 0).
anova(m3, m2)

cbind("PoissonGLM" = c(NA, coef(m0)),
      "PoissonML" = coef(m2),
      "PGeneraliz" = coef(m3))

# Perfil para o parâmetro de dispersão.
plot(profile(m3, which = "alpha"))
abline(v = 0, lty = 2)

V <- cov2cor(vcov(m3))
corrplot.mixed(V, upper = "ellipse", col = "gray50")
dev.off()

# Tamanho das covariâncias com \alpha.
each(sum, mean, max)(abs(V[1, -1]))

# Teste de Wald para a interação.
a <- c(0, attr(model.matrix(m0), "assign"))
ai <- a == max(a)
L <- t(replicate(sum(ai), rbind(coef(m3) * 0), simplify = "matrix"))
L[, ai] <- diag(sum(ai))

# Cáclculo da estatística Chi-quadrado.
crossprod(L %*% coef(m3),
          solve(L %*% vcov(m3) %*% t(L),
                L %*% coef(m3)))

linearHypothesis(model = m0,
                 hypothesis.matrix = L,
                 vcov. = vcov(m3),
                 coef. = coef(m3))
```

## Número de Capulhos Produzidos em Algodão ##

```{r}
#-----------------------------------------------------------------------
# Número de capulhos em função do nível de desfolha artificial e fase
# fenológica do algodoeiro.

data(capdesfo, package = "MRDCr")
str(capdesfo)

p1 <- xyplot(ncap ~ des | est, data = capdesfo,
             col = 1, type = c("p", "smooth"), col.line = "gray50",
             layout = c(2, 3), as.table = TRUE,
             xlim = extendrange(c(0:1), f = 0.15),
             xlab = "Nível de desfolhas artificial",
             ylab = "Número de capulho produzidos",
             spread = 0.035, panel = panel.beeswarm)
p1

#-----------------------------------------------------------------------
# Modelo Poisson.

m0 <- glm(ncap ~ est * (des + I(des^2)),
          data = capdesfo, family = poisson)

par(mfrow = c(2, 2))
plot(m0); layout(1)

anova(m0, test = "Chisq")
summary(m0)

#-----------------------------------------------------------------------
# Modelo Poisson Generalizada.

L <- with(capdesfo, list(y = ncap, offset = 1, X = model.matrix(m0)))

start <- c(alpha = log(1), coef(m0))
parnames(llpg) <- names(start)

# Modelo Poisson também.
m2 <- mle2(llpg, start = start, data = L,
           fixed = list(alpha = 0), vecpar = TRUE)

c(logLik(m2), logLik(m0))

# Modelo Poisson Generalizado.
m3 <- mle2(llpg, start = start, data = L, vecpar = TRUE)
logLik(m3)

anova(m3, m2)

summary(m3)

plot(profile(m3, which = "alpha"))

cbind("PoissonGLM" = c(NA, coef(m0)),
      "PoissonML" = coef(m2),
      "PGeneraliz" = coef(m3))

V <- cov2cor(vcov(m3))
corrplot.mixed(V, upper = "ellipse", col = "gray50")
dev.off()

# Tamanho das covariâncias com \alpha.
each(sum, mean, max)(abs(V[1, -1]))

# Teste de Wald para a interação.
a <- c(0, attr(model.matrix(m0), "assign"))
ai <- a == max(a)
L <- t(replicate(sum(ai), rbind(coef(m3) * 0), simplify = "matrix"))
L[, ai] <- diag(sum(ai))

# Teste de Wald explicito.
crossprod(L %*% coef(m3),
          solve(L %*% vcov(m3) %*% t(L),
                L %*% coef(m3)))

# Teste de Wald para interação (poderia ser LRT, claro).
# É necessário um objeto glm, mas necesse caso ele não usado para nada.
linearHypothesis(model = m0,
                 hypothesis.matrix = L,
                 vcov. = vcov(m3),
                 coef. = coef(m3))

#-----------------------------------------------------------------------
# Predição com bandas de confiança.

pred <- with(capdesfo, expand.grid(est = levels(est),
                                   des = seq(0, 1, by = 0.025)))
X <- model.matrix(formula(m0)[-2], data = pred)

pred <- list(pois = pred, pgen = pred)

# Quantil normal.
qn <- qnorm(0.975) * c(lwr = -1, fit = 0, upr = 1)

# Preditos pela Poisson.
aux <- confint(glht(m0, linfct = X),
               calpha = univariate_calpha())$confint
colnames(aux)[1] <- "fit"
pred$pois <- cbind(pred$pois, exp(aux))
str(pred$pois)

# Matrix de covariância completa e sem o alpha.
V <- vcov(m3)
V <- V[-1,-1]
U <- chol(V)
aux <- sqrt(apply(X %*% t(U), MARGIN = 1,
                  FUN = function(x) { sum(x^2) }))
pred$pgen$eta <- c(X %*% coef(m3)[-1])
pred$pgen <- cbind(pred$pgen,
                   apply(outer(aux, qn, FUN = "*"), MARGIN = 2,
                         FUN = function(x) {
                             exp(pred$pgen$eta + x)
                         }))
str(pred$pgen)

pred <- ldply(pred, .id = "modelo")
pred <- arrange(pred, est, des, modelo)
str(pred)

key <- list(lines = list(
                lty = 1,
                col = trellis.par.get("superpose.line")$col[1:2]),
            text = list(
                c("Poisson", "Poisson Generalizada")))

p2 <- xyplot(fit ~ des | est, data = pred, groups = modelo,
             layout = c(NA, 1), as.table = TRUE,
             xlim = extendrange(range(pred$des), f = 0.1),
             type = "l", key = key,
             ly = pred$lwr, uy = pred$upr, cty = "bands", alpha = 0.5,
             prepanel = prepanel.cbH,
             panel.groups = panel.cbH,
             panel = panel.superpose)
# p2
```

```{r, fig.width=7, fig.height=3.5}
update(p1, type = "p", layout = c(NA, 1),
       key = key, spread = 0.07) +
    as.layer(p2, under = TRUE)
```

## Mosca Branca ##

```{r}
data(ninfas, package = "MRDCr")
str(ninfas)

# xyplot(ntot ~ dias | cult, data = ninfas,
#        type = c("p", "spline"),
#        grid = TRUE, as.table = TRUE, layout = c(NA, 2),
#        xlab = "Dias", ylab = "Número total de ninfas")

# Somente as cultivares que contém BRS na identificação
ninfas <- droplevels(subset(ninfas, grepl("BRS", x = cult)))

xyplot(ntot ~ dias | cult, data = ninfas,
       type = c("p", "spline"),
       grid = TRUE, as.table = TRUE, layout = c(NA, 2),
       xlab = "Dias", ylab = "Número total de ninfas")

# IMPORTANT: Foi usado um offset de 100 por problemas de
# over/underflow. O problema não é com a Poisson mas com a Poisson
# Generalizada. Todas as análises consideram um offset de 100, portanto,
# permanecem comparáveis e igualmente interpretáveis.

ninfas <- transform(ninfas,
                    off = 100,
                    aval = factor(dias))

#-----------------------------------------------------------------------
# Modelo Poisson.

m0 <- glm(ntot ~ offset(log(off)) + bloco + cult * aval,
          data = ninfas, family = poisson)

par(mfrow = c(2, 2))
plot(m0); layout(1)

anova(m0, test = "Chisq")
anova(m0, test = "Chisq",
      dispersion = sum(residuals(m0, type = "pearson")^2)/
          df.residual(m0))
summary(m0)

m0 <- glm(ntot ~ offset(log(off)) + bloco + cult + aval,
          data = ninfas, family = poisson)
anova(m0, test = "Chisq",
      dispersion = sum(residuals(m0, type = "pearson")^2)/
          df.residual(m0))
summary(m0)

#-----------------------------------------------------------------------
# Modelo Poisson Generalizada.

L <- with(ninfas, list(y = ntot, offset = off, X = model.matrix(m0)))

start <- c(alpha = 0, coef(m0))
parnames(llpg) <- names(start)

# Modelo Poisson também.
m2 <- mle2(llpg, start = start, data = L,
           fixed = list(alpha = 0), vecpar = TRUE)

c(logLik(m2), logLik(m0))

# Modelo Poisson Generalizado.
m3 <- mle2(llpg, start = start, data = L, vecpar = TRUE)
logLik(m3)

anova(m3, m2)

summary(m3)

plot(profile(m3, which = "alpha"))

cbind("PoissonGLM" = c(NA, coef(m0)),
      "PoissonML" = coef(m2),
      "PGeneraliz" = coef(m3))

V <- cov2cor(vcov(m3))
corrplot.mixed(V, upper = "ellipse", col = "gray50")
dev.off()

# Tamanho das covariâncias com \alpha.
each(sum, mean, max)(abs(V[1, -1]))

# Teste de Wald para a interação.
a <- c(0, attr(model.matrix(m0), "assign"))
ai <- a == max(a)
L <- t(replicate(sum(ai), rbind(coef(m3) * 0), simplify = "matrix"))
L[, ai] <- diag(sum(ai))

# Teste de Wald explicito.
crossprod(L %*% coef(m3),
          solve(L %*% vcov(m3) %*% t(L),
                L %*% coef(m3)))

# Teste de Wald para interação (poderia ser LRT, claro).
# É necessário um objeto glm, mas necesse caso ele não usado para nada.
linearHypothesis(model = m0,
                 hypothesis.matrix = L,
                 vcov. = vcov(m3),
                 coef. = coef(m3))

#-----------------------------------------------------------------------
# Predição com bandas de confiança.

pred <- with(ninfas, expand.grid(off = 100,
                                 bloco = factor(levels(bloco)[1],
                                                levels = levels(bloco)),
                                 cult = levels(cult),
                                 aval = levels(aval),
                                 KEEP.OUT.ATTRS = FALSE))
X <- model.matrix(formula(m0)[-2], data = pred)

bl <- attr(X, "assign") == 1
X[, bl] <- X[, bl] * 0 + 1/(sum(bl) + 1)
head(X)

pred <- list(pois = pred, pgen = pred)

# Quantil normal.
qn <- qnorm(0.975) * c(lwr = -1, fit = 0, upr = 1)

# Preditos pela Poisson.
aux <- confint(glht(m0, linfct = X),
               calpha = univariate_calpha())$confint
colnames(aux)[1] <- "fit"
pred$pois <- cbind(pred$pois, sweep(exp(aux), 1, pred$pois$off, "*"))
str(pred$pois)

# Matrix de covariância completa e sem o alpha.
V <- vcov(m3)
V <- V[-1,-1]

U <- chol(V)
aux <- sqrt(apply(X %*% t(U), MARGIN = 1,
                  FUN = function(x) { sum(x^2) }))
pred$pgen$eta <- c(X %*% coef(m3)[-1])
pred$pgen <- cbind(pred$pgen,
                   apply(outer(aux, qn, FUN = "*"), MARGIN = 2,
                         FUN = function(x) {
                             pred$pgen$off * exp(pred$pgen$eta + x)
                         }))
str(pred$pgen)

pred <- ldply(pred, .id = "modelo")
pred <- arrange(pred, cult, aval, modelo)
str(pred)

key <- list(lines = list(
                lty = 1,
                col = trellis.par.get("superpose.line")$col[1:2]),
            text = list(
                c("Poisson", "Poisson Generalizada")))

xyplot(ntot ~ aval | cult, data = ninfas,
       grid = TRUE, as.table = TRUE, layout = c(NA, 2),
       xlab = "Dias", ylab = "Número total de ninfas",
       key = key) +
    as.layer(xyplot(fit ~ aval | cult, data = pred,
                    groups = modelo, pch = 19, type = "o",
                    ly = pred$lwr, uy = pred$upr,
                    cty = "bars", length = 0.05,
                    desloc = 0.2 * scale(as.integer(pred$modelo),
                                         scale = FALSE),
                    prepanel = prepanel.cbH,
                    panel.groups = panel.cbH,
                    panel = panel.superpose), under = TRUE)

#-----------------------------------------------------------------------

fun <- Vectorize(vectorize.args = c("lambda", "alpha"),
                 FUN = function(lambda, alpha) {
                     sum(dpg1(y = y, lambda = lambda, alpha = alpha))
                 })

# dpg1(y = 0:10, lambda = 5, alpha = -0)
# dpois(0:10,  lambda = 5)

head(sort(subset(pred, modelo = "pois")$fit, decreasing = TRUE))
coef(m3)["alpha"]

y <- 0:400
grid <- list(lambda = seq(10, 200, by = 2),
             alpha = seq(-0.05, 0.1, by = 0.001))
grid$sum <- with(grid, outer(lambda, alpha, fun))

grid <- with(grid,
             cbind(expand.grid(lambda = lambda, alpha = alpha),
                   data.frame(sum = c(sum))))

levelplot(sum ~ lambda + alpha,
          data = subset(grid, round(sum, 3) == 1),
          col.regions = gray.colors) +
    layer(panel.abline(h = 0.05))

```

## Pacote VGAM ##

```{r, eval=FALSE}
#-----------------------------------------------------------------------

# # http://finzi.psych.upenn.edu/library/VGAM/html/genpoisson.html
# library(VGAM)
#
# formula(m0)
# m1 <- vglm(formula(m0), data = cap, family = genpoisson, trace = TRUE)
# coef(m1, matrix = TRUE)
# summary(m1)
#
# logLik(m2)

```
